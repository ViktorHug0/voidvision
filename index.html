<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>VoidVision — Enter the Void</title>
  <meta name="description" content="VoidVision is a hypnotic, holographic portal: floating geometry, psychedelic visuals, and a random video drop—enter the void." />
  <meta name="robots" content="index,follow" />
  <meta name="theme-color" content="#6223d2" />

  <!-- Canonical -->
  <link rel="canonical" href="https://voidvision.xyz/" />

  <!-- Icons -->
  <link rel="icon" href="/favicon.svg" type="image/svg+xml" />
  <link rel="apple-touch-icon" href="/favicon.svg" />

  <!-- Open Graph -->
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="VoidVision" />
  <meta property="og:title" content="VoidVision — Enter the Void" />
  <meta property="og:description" content="A hypnotic, holographic portal: floating geometry, psychedelic visuals, and a random video drop." />
  <meta property="og:url" content="https://voidvision.xyz/" />
  <meta property="og:image" content="https://voidvision.xyz/og.svg" />

  <!-- Twitter -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="VoidVision — Enter the Void" />
  <meta name="twitter:description" content="A hypnotic, holographic portal: floating geometry, psychedelic visuals, and a random video drop." />

  <!-- Structured data -->
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "VoidVision",
      "url": "https://voidvision.xyz/",
      "inLanguage": "en"
    }
  </script>

  <!-- Performance -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link rel="stylesheet" href="style.css?v=2025-12-19" />
  <link href="https://fonts.googleapis.com/css2?family=Monoton&display=swap" rel="stylesheet">

  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4959493300348608"
     crossorigin="anonymous"></script>
     
</head>
<body>
  <!-- Animated background -->
  <div class="overlay"></div>
  <div class="container" id="container"></div>

  <!-- Foreground content -->
  <div class="content">
    <h1>VoidVision</h1>

    <div class="video-container">
      <div class="psychedelic-border"></div>
      <div class="responsive-iframe">
        <iframe
          id="youtube-player"
          src="https://www.youtube-nocookie.com/embed/dQw4w9WgXcQ?rel=0&playsinline=1"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
          allowfullscreen
        ></iframe>
      </div>
    </div>

   <button id="change-video" class="btn hologram">
  <span data-text="Enter the Void">Enter the Void</span>
  <div class="scan-line"></div>
</button>
  </div>

  <script>
    /* === Animated Triangle Background === */
    function getTriangleSizePx() {
      // Custom properties may return raw expressions (e.g. "calc(...)"), so measure real px via a probe element.
      const probe = document.createElement("div");
      probe.style.position = "absolute";
      probe.style.visibility = "hidden";
      probe.style.pointerEvents = "none";
      probe.style.width = "var(--tri-w)";
      probe.style.height = "var(--tri-h)";
      document.body.appendChild(probe);

      const rect = probe.getBoundingClientRect();
      probe.remove();

      const w = rect.width || 50;
      const h = rect.height || (w * 1.15);
      return { w, h };
    }

    function createTriangle(num, color) {
      const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      polygon.setAttribute("points", "");
      polygon.setAttribute("fill", "none");
      polygon.setAttribute("stroke", color);
      polygon.setAttribute("stroke-width", "5");

      const animate = document.createElementNS("http://www.w3.org/2000/svg", "animate");
      animate.setAttribute("attributeName", "points");
      animate.setAttribute("repeatCount", "indefinite");
      animate.setAttribute("dur", "4s");
      animate.setAttribute("begin", num + "s");
      animate.setAttribute("from", "50 57.5, 50 57.5, 50 57.5");
      animate.setAttribute("to", "50 -75, 175 126, -75 126");

      polygon.appendChild(animate);
      return polygon;
    }

    function generateTriangles() {
      const container = document.getElementById("container");
      const { w: TRIANGLE_WIDTH, h: TRIANGLE_HEIGHT } = getTriangleSizePx();
      
      // Clear existing triangles
      container.innerHTML = '';
      
      // Calculate grid dimensions based on viewport
      // Horizontal: standard calculation
      const cols = Math.ceil(window.innerWidth / TRIANGLE_WIDTH) + 4; // +4 for overflow
      
      // Vertical: account for 25% overlap (each row after first only adds 75% height)
      const effectiveRowHeight = TRIANGLE_HEIGHT * 0.75;
      const rows = Math.ceil(window.innerHeight / effectiveRowHeight) + 6; // +6 for overflow
      
      // Set grid template dynamically
      container.style.gridTemplateColumns = `repeat(${cols}, ${TRIANGLE_WIDTH}px)`;
      container.style.gridTemplateRows = `repeat(${rows}, ${TRIANGLE_HEIGHT}px)`;
      
      const totalTriangles = cols * rows;
      
      // Generate triangles
      for (let i = 0; i < totalTriangles; i++) {
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("class", "shape");
        svg.setAttribute("viewBox", "0 0 100 115");
        svg.setAttribute("preserveAspectRatio", "xMidYMin slice");
        
        // Calculate row and apply hexagonal pattern transform
        const row = Math.floor(i / cols);
        const horizontalOffset = (row % 2 === 1) ? -50 : 0;
        const verticalOffset = row * -25;
        
        // Apply transform for hexagonal tessellation
        if (row > 0) {
          svg.style.transform = `translate(${horizontalOffset}%, ${verticalOffset}%)`;
        }

        svg.appendChild(createTriangle(0, "hsl(320,100%,70%)"));
        svg.appendChild(createTriangle(1, "hsl(240,100%,70%)"));
        svg.appendChild(createTriangle(2, "hsl(160,100%,70%)"));
        svg.appendChild(createTriangle(3, "hsl(80,100%,70%)"));

        container.appendChild(svg);
      }
      
      console.log(`Generated ${totalTriangles} triangles (${cols} cols × ${rows} rows)`);
    }

    // Generate triangles on load
    document.addEventListener("DOMContentLoaded", generateTriangles);
    
    // Regenerate on window resize (debounced)
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(generateTriangles, 300);
    });

    /* === Random YouTube Video Player === */
    const YOUTUBE_EMBED_BASE = "https://www.youtube-nocookie.com/embed/";
    const YOUTUBE_EMBED_PARAMS = "?rel=0&playsinline=1";

    // If you open this page via `file://`, some browsers/privacy settings block third‑party iframes.
    // Serve it via a local web server (e.g. `python3 -m http.server`) and open `http://localhost:8000`.
    if (location.protocol === "file:") {
      console.warn(
        "[VoidVision] YouTube embeds may not load reliably from file://. Try serving this folder over http://localhost."
      );
    }

    const videoIds = [
      "dS-MaUk6YBI",
      "vWiCVO3X_Ec",
      "w_MSFkZHNi4",
      "o0u4M6vppCI",
      "QrGrOK8oZG8",
      "2gMjJNGg9Z8",
      "x-pj8OtyO2I",
      "zt2uIhAvQZ8",
      "qLrnkK2YEcE",
      "NhheiPTdZCw",
      "E-6xk4W6N20",
      "TuJqUvBj4rE",
      "CWnqX41JHuM",
      "9RHFFeQ2tu4",
      "IvUU8joBb1Q",
      "iu5rnQkfO6M",
      "sBzrzS1Ag_g",
      "tSHHl7aRX9o",
      "BqnG_Ei35JE",
      "tmozGmGoJuw",
      "pFptt7Cargc",
      "skD7r0yWOG4",
      "59QBOO6m210",
      "TgqiSBxvdws",
      "9C_HReR_McQ",
      "vtkGtXtDlQA",
      "sXOdn6vLCuU",
      "G9FGgwCQ22w",
      "tS_Xq7gSCBM",
      "dbL-NSkXnl8",
      "v6yg4ImnYwA",
      "ornXZGEFcds",
      

    ];

    // Track recently played videos (session-local)
    const RECENT_WINDOW = 20;
    // Smaller => harsher penalty for recent videos; bigger => milder penalty.
    const PENALTY_DECAY = 0.65;
    const recentHistory = [];

    function normalizeVideoIds(ids) {
      // de-dupe + remove falsy entries
      return Array.from(new Set(ids.filter(Boolean)));
    }

    function pushRecent(id) {
      if (!id) return;
      // Remove existing occurrence so it becomes "most recent"
      const existingIdx = recentHistory.indexOf(id);
      if (existingIdx !== -1) recentHistory.splice(existingIdx, 1);
      recentHistory.push(id);
      while (recentHistory.length > RECENT_WINDOW) recentHistory.shift();
    }

    function weightForId(id) {
      // Most recent gets the strongest penalty; older recent items get less penalty.
      const idx = recentHistory.indexOf(id);
      if (idx === -1) return 1;

      const ageFromMostRecent = (recentHistory.length - 1) - idx; // 0 = most recent
      const exponent = Math.max(0, RECENT_WINDOW - ageFromMostRecent);
      return Math.pow(PENALTY_DECAY, exponent);
    }

    function weightedPick(ids) {
      let total = 0;
      const weights = ids.map((id) => {
        const w = weightForId(id);
        total += w;
        return w;
      });

      // Fallback (shouldn't happen unless ids is empty)
      if (total <= 0) return ids[0];

      let r = Math.random() * total;
      for (let i = 0; i < ids.length; i++) {
        r -= weights[i];
        if (r <= 0) return ids[i];
      }
      return ids[ids.length - 1];
    }

    function pickNextVideoId(currentId) {
      const ids = normalizeVideoIds(videoIds);
      if (ids.length === 0) return null;
      if (ids.length === 1) return ids[0];

      const candidates = ids.filter((id) => id !== currentId);
      const chosen = weightedPick(candidates.length ? candidates : ids);
      return chosen;
    }

    function activatePsychedelicEffect() {
      const border = document.querySelector(".psychedelic-border");
      border.classList.add("active");
      setTimeout(() => {
        border.classList.remove("active");
      }, 1300);
    }

    function setVideoById(id) {
      const iframe = document.getElementById("youtube-player");
      if (!iframe || !id) return;
      iframe.src = `${YOUTUBE_EMBED_BASE}${id}${YOUTUBE_EMBED_PARAMS}`;
      pushRecent(id);
    }

    function initRandomVideo() {
      // Pick a random first video from the list on page load.
      const first = weightedPick(normalizeVideoIds(videoIds));
      setVideoById(first);
    }

    let voidClickCount = 0;
    let lockedVoidButtonWidthPx = null;

    function updateVoidButtonLabel() {
      const btn = document.getElementById("change-video");
      if (!btn) return;
      const label = btn.querySelector("span[data-text]");
      if (!label) return;

      let nextText = "Enter the Void";
      if (voidClickCount === 1) nextText = "One More";
      if (voidClickCount >= 2) nextText = "Keep Going";

      label.textContent = nextText;
      label.setAttribute("data-text", nextText);
    }

    function lockVoidButtonWidth() {
      // Lock the button enclosure to the initial "Enter the Void" size (prevents resize on later labels).
      const btn = document.getElementById("change-video");
      const label = btn?.querySelector("span[data-text]");
      if (!btn || !label) return;

      // Only compute once per page load.
      if (lockedVoidButtonWidthPx == null) {
        const prevText = label.textContent;
        const prevData = label.getAttribute("data-text");

        label.textContent = "Enter the Void";
        label.setAttribute("data-text", "Enter the Void");

        // Force layout, then measure
        const rect = btn.getBoundingClientRect();
        lockedVoidButtonWidthPx = Math.ceil(rect.width);

        // Restore
        label.textContent = prevText ?? "";
        if (prevData != null) label.setAttribute("data-text", prevData);
      }

      btn.style.width = `${lockedVoidButtonWidthPx}px`;
    }

    function changeVideo() {
      const iframe = document.getElementById("youtube-player");
      const currentVideoUrl = iframe.src;
      const currentVideoId = currentVideoUrl.split("/").pop().split("?")[0];
      activatePsychedelicEffect();
      const newVideoId = pickNextVideoId(currentVideoId);

      // Update button text after clicks
      voidClickCount += 1;
      updateVoidButtonLabel();

      setTimeout(() => {
        setVideoById(newVideoId);
      }, 10);
    }

    document.getElementById("change-video").addEventListener("click", changeVideo);
    document.addEventListener("DOMContentLoaded", initRandomVideo);
    document.addEventListener("DOMContentLoaded", updateVoidButtonLabel);
    document.addEventListener("DOMContentLoaded", lockVoidButtonWidth);
  </script>
</body>
</html>
